/* Jasmin Implementation of ARIA‑128 Block Cipher */
/* Reference: https://github.com/openssl/openssl/blob/master/crypto/aria/aria.c */

require "aria_globals.jinc"
require "aria_helpers.jinc"

export fn jyh_aria_set_encrypt_key(
    reg u64 userKeyAddr,      // pointer to userKey bytes
    reg u32 bits,             // 128, 192, or 256
    reg u64 keyPtrAddr        // pointer to ARIA_KEY struct
) -> reg u32 {
    reg u32 ret;
    ret = 0;

    // Local buffers
    stack u8[ARIA_BLOCK_SIZE] w0, w1, w2, w3;
    stack u8[ARIA_BLOCK_SIZE] kr, ck1, ck2, ck3, tmp;
    reg u32 rounds;
    inline int i, j;

    // // --- 1) Null pointers?
    // if userKeyAddr == 0 || keyPtrAddr == 0 {
    //     return -1;
    // }

    // --- 2) Load W0 = first 16 bytes of userKey
    for i = 0 to ARIA_BLOCK_SIZE - 1 {
        w0[i] = (u8)[userKeyAddr + i];
    }

    // --- 3) Select ARIA constants and init KR based on key length
    if bits == 128 {
        rounds = 12;
        for i = 0 to ARIA_BLOCK_SIZE - 1 {
            ck1[i] = c1[i];
            ck2[i] = c2[i];
            ck3[i] = c3[i];
            kr[i]  = 0;
        }
    }
    else if bits == 192 {
        rounds = 14;
        for i = 0 to ARIA_BLOCK_SIZE - 1 {
            ck1[i] = c2[i];
            ck2[i] = c3[i];
            ck3[i] = c1[i];
        }
        // load half of KR from userKey[16..23], zero pad the rest
        for i = 0 to (ARIA_BLOCK_SIZE/2 - 1) {
            kr[i] = (u8)[userKeyAddr + ARIA_BLOCK_SIZE + i];
        }
        for i = ARIA_BLOCK_SIZE/2 to ARIA_BLOCK_SIZE - 1 {
            kr[i] = 0;
        }
    }
    else if bits == 256 {
        rounds = 16;
        for i = 0 to ARIA_BLOCK_SIZE - 1 {
            ck1[i] = c3[i];
            ck2[i] = c1[i];
            ck3[i] = c2[i];
            kr[i]  = (u8)[userKeyAddr + ARIA_BLOCK_SIZE + i];
        }
    }
    else {
        ret = -2;
    }

    // Store rounds count (u32) at end of ARIA_KEY
    (u32)[ keyPtrAddr + (ARIA_MAX_KEYS * ARIA_BLOCK_SIZE) ] = rounds;

    // --- 4) Compute intermediate Feistel words W1..W3
    // W1 = FO(W0, CK1) ⊕ KR
    FO(tmp, w0, ck1);
    xor128(w1, tmp, kr);

    // W2 = FE(W1, CK2) ⊕ W0
    FE(tmp, w1, ck2);
    xor128(w2, tmp, w0);

    // W3 = FO(W2, CK3) ⊕ W1
    FO(tmp, w2, ck3);
    xor128(w3, tmp, w1);

    // --- 5) Expand round keys into key->rd_key[0..rounds]
    // We'll emit each 16‐byte subkey by rotating into 'tmp' and storing

    // Rounds  0.. 3: rot19r
    for i = 0 to 3 {
        // select inputs for this index
        if i == 0 { rot19r(tmp, w0, w1); }
        if i == 1 { rot19r(tmp, w1, w2); }
        if i == 2 { rot19r(tmp, w2, w3); }
        if i == 3 { rot19r(tmp, w3, w0); }
        // store 16 bytes
        for j = 0 to ARIA_BLOCK_SIZE - 1 {
            (u8)[ keyPtrAddr + (i*ARIA_BLOCK_SIZE) + j ] = tmp[j];
        }
    }

    // Rounds  4.. 7: rot31r
    for i = 4 to 7 {
        if i == 4 { rot31r(tmp, w0, w1); }
        if i == 5 { rot31r(tmp, w1, w2); }
        if i == 6 { rot31r(tmp, w2, w3); }
        if i == 7 { rot31r(tmp, w3, w0); }
        for j = 0 to ARIA_BLOCK_SIZE - 1 {
            (u8)[ keyPtrAddr + (i*ARIA_BLOCK_SIZE) + j ] = tmp[j];
        }
    }

    // Rounds  8..11: rot61l
    for i = 8 to 11 {
        if i == 8  { rot61l(tmp, w0, w1); }
        if i == 9  { rot61l(tmp, w1, w2); }
        if i == 10 { rot61l(tmp, w2, w3); }
        if i == 11 { rot61l(tmp, w3, w0); }
        for j = 0 to ARIA_BLOCK_SIZE - 1 {
            (u8)[ keyPtrAddr + (i*ARIA_BLOCK_SIZE) + j ] = tmp[j];
        }
    }

    // Round 12: rot31l
    rot31l(tmp, w0, w1);
    for j = 0 to ARIA_BLOCK_SIZE - 1 {
        (u8)[ keyPtrAddr + (12*ARIA_BLOCK_SIZE) + j ] = tmp[j];
    }

    // Rounds 13..14 if >12
    if rounds > 12 {
      rot31l(tmp, w1, w2);
      for j = 0 to ARIA_BLOCK_SIZE - 1 {
          (u8)[ keyPtrAddr + (13*ARIA_BLOCK_SIZE) + j ] = tmp[j];
      }
      rot31l(tmp, w2, w3);
      for j = 0 to ARIA_BLOCK_SIZE - 1 {
          (u8)[ keyPtrAddr + (14*ARIA_BLOCK_SIZE) + j ] = tmp[j];
      }
    }

    // Rounds 15..16 if >14
    if rounds > 14 {
      rot31l(tmp, w3, w0);
      for j = 0 to ARIA_BLOCK_SIZE - 1 {
          (u8)[ keyPtrAddr + (15*ARIA_BLOCK_SIZE) + j ] = tmp[j];
      }
      rot19l(tmp, w0, w1);
      for j = 0 to ARIA_BLOCK_SIZE - 1 {
          (u8)[ keyPtrAddr + (16*ARIA_BLOCK_SIZE) + j ] = tmp[j];
      }
    }

    return ret;
}